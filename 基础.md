# 基础
---
- [1 编码规范](#1-编码规范)
- [2 变量](#2-变量)
- [3 常量](#3-常量)
---

## 1 编码规范
**1.1 package**
- package的命名尽量和目录保持一致
- package应该小写，不要使用下划线或者混合大小写
```
// Example
package demo
package main
```

**1.2 file**
- file应该小写，使用下划线分隔各单词
- file以.go为结尾
```
// Example
my_demo.go
```

**1.3 结构体**
- 采用驼峰命名法，首字母根据访问控制大写（package外可见）或小写（package外不可见）
```
// 多行声明
type User struct {
	Username string
	Email	 string
}

// Example
// 多行初始化
u := User {
	Username: "astaxie",
	Email:	  "astaxie@gmail.com",
}
```

**1.4 接口**
- 命名规则基本和结构体相同
- 单个函数的结构名以"er"作为后缀
```
// Grammar
type Reader interface {
	Read(p []byte) (n int, err error)
}
```

**1.5 变量**
- 和结构体类似，变量名称一般遵循驼峰命名法，首字母根据访问控制原则大写或小写，但遇到特有名词时，需要遵循以下规则: 
   - 如果变量为私有，且特有名词为首个单词，则使用小写，如apiClient
   - 其他情况都应当使用该名词原有的写法，如APIClient, repoID, UserID
   - 错误示例: UrlArray，应该写成urlArray或者URLArray
- 若变量类型为bool类型，则名称应以has, is, can或allow开头
```
// Example
var isExist bool
var hasConflict bool
var canManage bool
var allowGit bool
```

**1.6 常量**
- 常量均需使用全部大写字母组成，并使用下划线分词
```
// Example
const APP_VER = "1.0"
```
- 如果是枚举类型的常量，需要先创建相应类型
```
// Example
const {
	HTTP  Scheme = "http"
	HTTPS Scheme = "https"
}
```

**1.7 关键字**
|break   |default    |func  |interface|select|
|:-:     |:-:		 |:-:   |:-:      |:-:   |
|case    |defer      |go    |map      |struct|
|chan    |else       |goto  |package  |switch|
|const   |fallthrough|if    |range    |type  |
|continue|for        |import|return   |var   |
---

## 2 变量
**2.1 单声明变量**
- 第一种，指定变量类型，声明后若不赋值，使用默认值
```
// Grammar
var name type
name = value

// Example
// Style 1
var num1 int
num1 = 30

// Style 2
var num2 int = 30
```
- 第二种，根据值自行判断变量类型（type inference）
```
// Grammar
var name = value
```
- 第三种，省略 var ，注意 := 左侧的变量不应该是已经声明过的（多个变量同时声明时，至少保证一个是新变量），
函数外的每个语句都必须以关键字开始，因此 := 不能在函数外使用。

**2.2 多变量声明**
- 第一种，以逗号分隔，声明与赋值分开，若不赋值，存在默认值
```
// Grammar
var name1, name2, name3 type
name1, name2, name3 = v1, v2, v3

// Example
// Style 1
var a, b int
a = 1
b = 2

// Style 2
var a, b int = 1, 2
```
- 第二种，直接赋值，下面的变量类型可以是不同的类型
```
// Grammar
var name1, name2, name3 = v1, v2, v3

// Example
var a, s = 1, "Go"
```
- 第三种，集合类型
```
// Grammar
var(
 	name1 type1
	name2 type2
)

// Example
var(
	a int = 1
	s = "Go"
)
```

**2.3 注意事项**
- 变量必须先定义才能使用
- Go语言是静态语言，要求变量的类型和赋值的类型必须一致
- 变量名（同一个作用域内）不能冲突
- := 定义方式，左边的变量名至少有一个是新的，不能定义全局变量
- 变量定义了就要使用，否则无法通过编译
---

## 3 常量
**3.1 常量声明**
- 一组常量中，如果某个常量没有初始值，默认和上一行一致
```
// Grammar
const identifier type = value

//Example
// 单常量声明
// Style 1
const PATH string = "www.google.com"

// Style 2
const PI = 3.14

// 多常量声明
// Style 1
const C1, C2, C3 = 1, 2.0, "Go"

// Style 2
const (
	D1 int = 1
	D2 = 2.0
	D3 = "Go"
)
```

**3.2 iota**
- iota，特殊常量，可以被编译器自动修改的常量，
每当定义一个const，iota的初始值为0，每当定义一个常量，就会自动累加1，直到下一个const出现，清零
```
// Example
const (
	A = iota // iota iota = 0
	B        // iota iota = 1
	C        // iota iota = 2
	D = "Go" // "Go" iota = 3
	E        // "Go" iota = 4
	F = 100  // 100  iota = 5
	G        // 100  iota = 6
	H = iota // iota iota = 7
	I        // iota iota = 8
)

const (
	J = iota // iota iota = 0
)
```
---

## 4 数据类型
**4.1 基本数据类型**
- **Bool Type**
   - **keyword:** bool
   - **value:** true, false
   ```
   // Example
   var b1 bool
   b1 = true
   ```
- **Numeric Types**
   - **integer:** int8(-128 ~ 127), int16(-32768 ~ 32767), int32(-2147483648 ~ 2147483647), 
   int64(-9223372036854775808 ~ 9223372036854775807), uint8(0 ~ 255), uint16(0 ~ 65535),
   uint32(0 ~ 4294967295), uint64(0 ~ 18446744073709551615)
   - **float:** float32(), float64()
   - **complex:** complex64, complex128
   - **others:** byte(类似uint8), rune(类似int32), uint(32或64位), int(与uint一样大小), uintptr(无符号整型，用于存放一个指针)
- **String Type**
    - **UTF - 8**
    - **转义字符**
	   - \t: 制表符
	   - \\\\: 一个\
	   - \\": 一个"
	   - \n: 换行符
	   - \r: 回车符（光标移动到行首）（运行结果与\n相同，有待进一步验证）
	   ```
	   // Example
	   package main
	   import "fmt"
	   func main() {
		   fmt.Println("Tom\tJack")
	       fmt.Println("Tom\nJack")
		   fmt.Println("C:\\")
		   fmt.Println("\"Tom Jack\"")
		   fmt.Println("Jack\rTom")
	   }
	   ```
	   **Results**
	   ```
	   Tom	Jack
	   Tom
	   Jack
	   C:\
	   "Tom Jack"
	   Jack
	   Tom
	   ```
- **Type Convert**
   - 常数: 在有需要的时候会自动转型
   - 变量: 需要手动转型
   ```
   // Grammar 
   Type (Variable)

   // Example
   var a int = 10
   var b float64
   b = float(a)
   ```


**4.2 复合数据类型**
- Array, Slice, Map, Function, Pointer, Struct, Interface, Channel
---

## 5 运算符
**5.1 算数运算符**
- \+, \-, \*, /, %, \+\+, \-\-

**5.2 关系运算符**
- ==, !=, >, <, >=, <=

**5.3 逻辑运算符**
- &&, ||, !

**5.4 位运算符**
- &(按位与), |(按位或), ^(一元取反，二元异或), &^(a&^b: 按b中1的位清0), <<(左移位，放大2^n), >>(右移位，缩小2^n)

**5.5 赋值运算符**
- =, \+=, \-=, \*=, /=, %=, <<=, >>=, &=, |=, ^=, ...

**5.6 运算符优先级**
- **7.** \~, \!, \+\+, \-\-
- **6.** \*, /, %, <<, >>, &, &^
- **5.** \+, \-, ^
- **4.** ==, !=, <, <=, >=, >
- **3.** <-
- **2.** &&
- **1.** ||
---

## 6 输入输出
- **fmt包:** 输入，输出
- **输出:** Print(), Printf(), Println()
- **格式化打印占位符**
   - %v: 原样输出
   - %T: 打印类型
   - %t: Bool类型
   - %s: 字符串
   - %f: 浮点
   - %d: 10进制整数
   - %b: 2进制整数
   - %o: 8进制整数
   - %x: 16进制，0-9，a-f
   - %X: 16进制，0-9，A-F
   - %c: 打印字符
   - %p: 打印地址
- **输入:** Scanln(), Scanf()
```
// Example
var x int
var y float64

fmt.Scanln(&x, &y) // input 100 3.14
fmt.Scanf("%d,%f", &x, &y) // input 100,3.14
fmt.Printf("x: %d, y: %f", x, y) // output x: 100, y: 3.14

reader := bufio.NewReader(os.Stdin)
s1, _ := reader.ReadString("\n") // input "Go"
fmt.Println(s1) // output "Go"
```
---

## 7 程序的流程控制
**7.1 条件语句**
- **If**
```
// Grammar
// Type 1
if Bool Expression {
	// do when bool expression is true
}

// Type 2
if Bool Expression {
	// do when bool expression is true
} else {
	// do when bool expression is false
}

// Type 3
if Bool Expression 1 {
	// do when bool expression 1 is true
} else if Bool Expression 2 {
	// do when bool expression 2 is true
} else {
	// do when all bool expressions are false
}

// Type 4
if Statement(//Exp. num := 1); Bool Expression {
	// do when bool expression is true
}
```
- **Switch**
   - **break:** 强制结束
   - **fallthrough:** 执行符合条件的case和紧接着的一个case
```
// Grammar
// Type 1
switch variable {
	case value1:
		// do when variable is equal to value1
	case value2:
		// do when variable is equal to value2
	default:
		// do when variable is not equal to all values
}

// Type 2
switch {
	case Bool Expression 1:
		// do when Bool Expression 1 is true
	case Bool Expression 2:
		// do when Bool Expression 2 is true
	default:
		// do when no bool expression is true
}

// Type 3
switch variable {
	case value1, value2, value3:
		// do when variable is equal to value1 or value2 or value3
	case value4, value5, value6:
		// do when variable is equal to value4 or value5 or value6
	default:
		// do when variable is not equal to all values
}

// Type 4
switch Statement; variable {
	case value1:
		// do when variable is equal to value1
	case value2:
		// do when variable is equal to value2
	default:
		// do when variable is not equal to all values
}
```
- **goto**
```
// Grammar
label: statement
...
goto label
```

**7.2 循环语句**
- **for**
   - **break:** 结束整个for循环
   - **continue:** 结束本次循环
```
// Grammar
// Type 1
for initialization; condition; post {
	// Circulatory body
}

// Example
for i := 1; i <= 5; i++ {
	// Circulatory body
}

// Type 2
// same as while condition: in Python
for condition {
	// Circulatory body
}

// Example
for {
	// infinite loop
}

// Type 3
for index, value := range array1 {
	// traverse the array
}
```
---

## 8 Array
- **len(array):** 数组中实际存储的数据量
- **cap(array):** 数组中最大存储的数据量
```
// Grammar
var variable_name [SIZE] variable_type

// Example
// Type 1
var arr1 [2]int // same as var a = [2]int
arr1[0] = 1
arr1[1] = 2

// Type 2
var b = [2]int{1, 2} // output [1 2]

// Type 3
var c = [4]int{1, 2} // ouput [1 2 0 0]

// Type 4
var d = [4]int{1:2, 3:4} // output [0 2 0 4]

// Type 5
var e = [2] string {"go"} // output ["go" ""]

// Type 6
f := [...]int{1, 2, 3} // output [1 2 3]

// Type 7
g := [...]int{2:2} // output [0 0 2]
```
- **多维数组**
```
// Grammar
// Example
arr1 := [2][3]int{
	{1, 2, 3},
	{4, 5, 6},
}
// Traverse
for _, arr := range arr1 {
	for _, val := range arr {
		// do something
	}
}
```
---

## 9 Slice
**\* Slice 是引用类型**
```
// Grammar
// Type 1
var identifier []Type

// Type 2
var slice []Type = make([]Type, len)

// Type 3
make([]Type, length, capacity)

// Example
s1 := []int{1, 2, 3, 4}
s2 := make([]int, 3, 8)
s3 := "GO"
s4 := []byte(s3)
```
- **append** 
```
// Type 1
slice = append(slice, elem1, elem2)

// Type 2
slice = append(slice, anotherSlice...)

// Example
s3 := make([]int, 0, 5)
s3 = append(s3, 1, 2) // output [1 2]
s3 = append(s3, s1...) // output [1 2 1 2 3 4]
```
- **from array to slice**
```
// Grammar
s := arr[startIndex:endIndex] // [startIndex, endIndex)
s := arr[startIndex:]         // [startIndex, endOfArray)
s := arr[:endIndex]           // [startOfArray, endIndex)
s := arr[:]                   // [startOfArray, endOfArray]
```
- **deep copy**
```
// Grammar
copy(dst, src []Type) int

// Example
s1 := []int{1, 2, 3}
s2 := []int{4, 5, 6, 7}
copy(s1, s2)         // output {4, 5, 6, 7}
copy(s2, s1)         // output {1, 2, 3, 7}
copy(s2[1:], s1[1:]) // output {4, 2, 3, 7}
```
---

## 10 Map
- map是无序的，每次打印出来的map都会不一样，类似Python中的字典
- map的长度是不固定的，和slice一样，是引用类型
- len函数适用于map，返回key的数量
- key是可比较的类型，如bool, int, float, string ...
- 未初始化的map为nil map，不能存放键值对
```
// Grammar
// Type 1
var map_variable map[key_type]value_type

// Type 2
map_variable := make(map[key_type]value_type)

// Type 3
// Example
rating := map1[string]float32 {
	"C": 5,
	"Go": 4.5
}

// get value
v1, ok := map1[40]
if ok {
	fmt.Println(v1)
} else {
	fmt.Println("key does not exist, return default value", v1)
}

// delete operation
delete(map1, "C")

//traverse operation
for key, value := range map1 {
	fmt.Println(key, value)
}
